// **---TZ-TASK-STAGE---**
//0.1 ЭТАП_В начале считываем саму форму из файла index.html, а также все ее элементы.

// НАЧАЛО
// *** Скрипт для валидации формы ***

// считываем форму
const form = document.forms['form'];
// формируем массив из элементов формы
const formArr = Array.from(form);
// в этом массиве хранятся поля, которые нужно проверить
const validFormArr = [];
// считываем кнопку
const button = form.elements['button'];

// **---TZ-TASK-STAGE---**
//0.2 ЭТАП_Далее формируем массив полей формы, которые будем проверять на валидность. Он называется validFormArr.
// Для этого сначала «прогоняем» массив всех полей формы и ищем те поле, в которых задан атрибут data-reg.

//0.3 ЭТАП_В конце добавляем обработчики событий для элемента формы form.
// Вызываем функцию inputHandler при событии input — т.е. вводе значений в поля.
// А функцию buttonHandlerвызываем при клике по кнопке button.

// Основной массив, заполнение(пушить) всеми инпутами на валидность
formArr.forEach((el) => {
  if (el.hasAttribute('data-reg')) {
    // кастомный аттрибут для поверки на валидность, 0 - по умолчанию
    el.setAttribute('is-valid', 0);
    validFormArr.push(el);
  }
});

form.addEventListener('input', inputHandler);
form.addEventListener('submit', formCheck);

// **---TZ-TASK-STAGE---**
// //0.4 ЭТАП_После пишем сами функции для проверки валидности.
// Первая функция inputHandler проверяет есть ли у выбранного поля атрибут data-reg,
// и если есть, вызывает другую функцию inputCheck, которая как раз проверяет валидность.
// Функция inputCheck принимает поле формы, считывает его значений,
// а также само регулярное выражение data-reg.
// После чего создаем объект RegExp, которые как раз нужен для работы с «регулярками».
// С помощью метода test проверяем соответствует ли введенное значение в поле нашему регулярному выражению.
// Если соответствует, то делаем поле зеленым. В противном случае красным.

function inputHandler({ target }) {
  if (target.hasAttribute('data-reg')) {
    inputCheck(target);
  }
}

function inputCheck(el) {
  const inputValue = el.value;
  const inputReg = el.getAttribute('data-reg');
  // преобраз. рег.выражения в строку
  const reg = new RegExp(inputReg);
  // **выше данные для проверки **
  // **проверка поля на валидность =>> **
  // проверка ввода на соответствие регул. выражению
  if (reg.test(inputValue)) {
    // если проверка пройдена -1
    el.setAttribute('is-valid', '1');
    el.style.border = '2px solid rgb(0, 196, 0)';
  } else {
    // если проверка не пройдена- 0
    el.setAttribute('is-valid', '0');
    el.style.border = '2px solid rgb(255, 0, 0)';
  }
}

// **---TZ-TASK-STAGE---**
// //0.5 ЭТАП_Последняя функция buttonHandler предназначена для обработки нажатия кнопки.
// В начале создаем массив allValid — в него будем добавлять логические значения (0 и 1) для проверки валидности каждого поля.
// Далее с помощью функции reduce проходим по массиву allValid.
// Если все поля валидные, то функция вернет true.
// Если хоть одно поле не соответствует маске, то вернет false.
// В конце проверяем итоговое значение isAllValid,
// если хоть одно поле не валидное — блокируем отправку формы.

// Здесь проверяем, можно ли отправить форму
function formCheck(e) {
  e.preventDefault(); //блокировка события
  // если одно поле невалидное(красное) -кнопка блокируется
  const AllValid = [];
  validFormArr.forEach((el) => {
    AllValid.push(el.getAttribute('is-valid')); // проверяем каждое поле
  });
  // ** общая проверка для всего массива **
  // прогон значений для общего значения
  const isAllValid = AllValid.reduce((acc, current) => {
    return acc && current;
  });
  if (!Boolean(Number(isAllValid))) {
    alert('Заполните поля правильно!'); // если не правильно - сообщение пользователю
    return;
  }
  formSubmit(); // если правильно - отправляем данные
}

// **---TZ-TASK-STAGE---**
// Самое основное начинается с нажатии на кнопку «Отправить»,
// после этого вызывается функция formCheck,
// которая (как понятно из названия) проверяет форму на корректность заполненных данных.
// Сначала мы формируем массив валидных значений, он выглядит примерно так allValid = [0, 1, 1, 0],
// где 0 — поле заполнено неверно, 1 — поле заполнено верно.

// После чего сводим весь массив allValid к единому значений isAllValid.
// Если в массиве allValid все единички, тогда isAllValue = true,
// в противном случае проверка не пройдена (тогда будет сообщение пользователю).
// Если проверка пройдена вызываем по цепочке функцию formSubmit.

// **---TZ-TASK-STAGE---**
// Отправка данных на почту
// Теперь, когда проверка пройдена, можем отправить данные на почту без перезагрузки страницы.
// В этом нам поможем асинхронная функция formSubmit.

async function formSubmit() {
  const data = serializeForm(form); // получаем данные формы
  const response = await sendData(data); // отправляем данные на почту
  if (response.ok) {
    let result = await response.json(); // если ответ OK отвечает пользователю
    alert(result.message); // .. что данные отправлены
    formReset(); // сбрасываем поля формы
  } else {
    alert('Код ошибки: ' + response.status); // если not OK - показываем код ошибки
  }
  // console.log("Проверка пройдена, данные отправляются . .");
}

function serializeForm(formNode) {
  // формируем данные формы
  return new FormData(form);
}

async function sendData(data) {
  return await fetch('send_mail.php', {
    // отправляем в скрипт send_mail.php
    method: 'POST', // методом POST
    body: data,
  });
}

function formReset() {
  // сброс полей формы
  form.reset();
  validFormArr.forEach((el) => {
    el.setAttribute('is-valid', 0);
    el.style.border = 'none';
  });
}

// **---TZ-TASK-STAGE--- ВЫШЕ**
// В начале собираем данные с формы с помощью функции serializeForm.
// Далее эти данные передаем в скрипт send_mail.php функцией sendData.
// PHP-скрипт сам занимается отправкой сообщения на почту.
// А мы тем временем ожидаем ответа от PHP-скрипта (специально указали await перед sendData).
// В этом собственно и заключается асинхронность.
// Как только ответ получен, то мы его проверяем:
// если все ОК — говорим пользователю, что сообщение отправлено и сбрасываем поля формы.
// В противном случае показываем код ошибки (с сервера).

// ERROR(maybe)
// дело было в неправильно прописанном пути в файле php, вот в этих строчках:
//  require "PHPMailer/src/PHPMailer.php";
//  где PHPMailer должно быть идентично названию папки в которой лежат файлы этой библиотеки.
